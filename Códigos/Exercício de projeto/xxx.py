# -*- coding: utf-8 -*-
"""xxx

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ci7L6WYLeJrN26wx5NIDp6LEWXi5VZq7
"""

import numpy as np 
import math
from decimal import *
getcontext().prec = 10

matriz_posicao = [[280, 0, 300]]
matriz_forca_max  = [[0, 16, 12]]
matriz_forca_min = [[0, -16, -12]]
F_max = 20
F_min = -20
matriz_momento = ''
d= ''
tensao_ruptura = 1000
lim_esc = 800
aco = 'laminado_quente'
carga = 'axial'
conf = 98
q = 1
kt = 1
n = 2
temp = 80
tensao_adm = lim_esc/n
#-----------------------------------------------------

#produto vetorial
def prod_vet(matriz_posicao, matriz_forca, matriz_momento):
  i = 0
  a = []

  while i < len(matriz_posicao):
      prod = np.cross(matriz_posicao[i], matriz_forca[i])
      prod = a.append(prod)
      prod = sum(a)
      i = i + 1

  if matriz_momento == '':
    matriz_forca = np.sum(matriz_forca, axis=0)
    t = prod[2]
    m = math.sqrt(((prod[0])**2) + ((prod[1])**2))
    
  else:
    matriz_forca = np.sum(matriz_forca, axis=0)
    matriz_momento = np.sum(matriz_momento, axis=0)
    prod = prod + matriz_momento
    t = prod[2]
    m = math.sqrt(((prod[0])**2) + ((prod[1])**2))
    

 
  return m,t

#momento máximo e torque máximo
x = prod_vet(matriz_posicao, matriz_forca_max, matriz_momento)

t_max = x[1]
m_max = x[0]


#momento mínimo e torque mínimo
y = prod_vet(matriz_posicao, matriz_forca_min, matriz_momento)

t_min = y[1]
m_min = y[0]


# determinar ka
def ka(aco):
  if aco == 'forjado':
    a = 272
    b = -0.995
    ka = a * (tensao_ruptura ** b)
  elif aco == 'laminado_quente':
      a = 57.7
      b = -0.718
      ka = a * (tensao_ruptura ** b)
  elif aco == 'usinado_ou_laminado_frio':
      a = 4.51
      b = -0.265
      ka = a * (tensao_ruptura ** b)
  elif aco == 'retificado':
      a = 1.58
      b = -0.085
      ka = a * (tensao_ruptura ** b)
  elif aco == 'espelhado':
      a = 1
      b = 0
      ka = a * (tensao_ruptura ** b)
  return ka

if ka(aco) > 1:
  ka = 1
else:
  ka = ka(aco)

# determinar kc
def kc(conf):
  if conf == 50:
    kc = 1
    
  elif conf == 90:
      kc = 0.897

  elif conf == 95:
      kc = 0.868

  elif conf == 98:
      kc = 0.836

  elif conf == 99:
      kc = 0.814

  elif conf == 99.99:
      kc = 0.702

  elif conf == 99.9999:
      kc = 0.620

  elif conf == 99.99999:
      kc = 0.584

  return kc

kc = kc(conf)

# determinar kd
def kd(temp):
  kd = 0.9877 + (0.6507 * (10**-3) * temp) - (0.3414 * (10**-5) * (temp**2)) + (0.5621 * (10**-8) * (temp**3)) - (6.246 * (10**-12) * (temp**4))

  return kd

if kd(temp) > 1:
  kd = 1
else:
  kd = kd(temp)

# determinar kf
kf = 1

#determinar o diâmetro inicial
d0 = ((32/(3.14*tensao_adm))*(math.sqrt((m_max**2)+((3/4)*(t_max**2)))))**(1/3)
tensao_cisalhante_esc = 0.577 * lim_esc

lim_normal_res = ka* 0.85 * kc * kd * 0.85 * kf * 0.5 * tensao_ruptura
lim_cisalhante_res = ka * 0.85 * kc * kd * 0.577 * kf * 0.5 * tensao_ruptura

# determinar o kp
def kp(q,kt):
    kp = 1 + (q * (kt - 1))
    return kp

def tensao_normal_max(d):
    return (kp(1,1) * ((32 * m_max) / (3.14 * d**3))) + (kp(1,1) * ((4 * F_max) / (3.14 * d**2)))
    
def tensao_normal_min(d):
    return (kp(1,1) * ((32 * m_min) / (3.14 * d**3))) + (kp(1,1) * ((4 * F_min) / (3.14 * d**2)))

def tensao_cisalhante_max(d):
    return (kp(1,1) * ((16 * t_max) / (3.14 * d**3)))

def tensao_cisalhante_min(d):
    return (kp(1,1) * ((16 * t_min) / (3.14 * d**3)))

def tensao_normal_var(d):
    return (tensao_normal_max(d) - tensao_normal_min(d)) / 2

def tensao_normal_media(d):
    return (tensao_normal_max(d) + tensao_normal_min(d)) / 2

def tensao_cisalhante_media(d):
    return (tensao_cisalhante_max(d) + tensao_cisalhante_min(d)) / 2

def tensao_cisalhante_var(d):
    return (tensao_cisalhante_max(d) - tensao_cisalhante_min(d)) / 2

def tensao_normal(d):
    return tensao_normal_media(d) + (tensao_normal_var(d) * (lim_esc/lim_normal_res))

def tensao_cisalhante(d):
    return tensao_cisalhante_media(d) + (tensao_cisalhante_var(d) * (tensao_cisalhante_esc/lim_cisalhante_res))

def f(d):
    return (n * (tensao_normal(d)**2 + (3* tensao_cisalhante(d)**2))**(1/2))/lim_esc

def flin(f, d):  
    if d == 0:
        d = 1
        h = d / 5471
        flin = (1/(12*h)) * ( f(d- 2*h) - 8*f(d - h) + 8*f(d+h) - f(d + 2*h) )
    else:
        h = d / 5471
        flin = (1/(12*h)) * ( f(d- 2*h) - 8*f(d - h) + 8*f(d+h) - f(d + 2*h) )
    return flin

def newton(f, d0, epsilon, maxIter=20):
    if abs(f(d0)) <= epsilon:
      return (d0)

    print("k\t d0\t\t f(d0)") #cabeçalho da tabela que retornará com os valores embaixo. \t é o espaçamento que dou para ficar visual.
    
    k=1
    while k <= maxIter:
        d1 = d0 - f(d0)/flin(f,d0)
        
    print("%d\t%e\t%e" % (k, d1,f(d1)))

    if abs(f(d1)) <= epsilon:
        return d1      
    
    d0 = d1
    k = k + 1
    
    print('ERRO: Número máximo de iterações atingido')

    return d1


raiz = newton(f,d0,10**-8,20)


print(raiz)

# while abs(d1 - d0) < 10**-8:
#     kb = f(d0)
#     #determinação dos limites de resistência para o cálculo das tensões
#     lim_normal_res = ka* kb * kc * kd * 0.85 * kf * 0.5 * tensao_ruptura
#     lim_cisalhante_res = ka * kb * kc * kd * 0.577 * kf * 0.5 * tensao_ruptura
  
#     raiz = newton(f,d0,10**-8,20)
      

#     print(raiz)